#include "std_msgs/Float32.h"
#include "ros/ros.h" //ncludes all the headers to use the most common public pieces of the ROS system
//#include "tf/transfrom_listener.h"//inherits from Transformer and automatically subscribes to ROS transform messages
#include "std_msgs/Float64MultiArray.h"
#include "std_msgs/Float64.h"
#include "geometry_msgs/PoseStamped.h"

float distance = 1.5;
#define INIT_P 0
#define W_FOR_POSE 1
#define SECOND_POSE 2
#define W_FOR_POSE_TWO 3
#define THIRD_POSE 4

geometry_msgs::PoseStamped position
void move_distance(const std_msgs::Float32::ConstPtr& msg)
{

//  msg->data = distance;

}
std_msgs::Float64MultiArray  servo_position(float q1, float q2, float q3, float q4, float q5, float q6, float q7)
{
    std_msgs::Float64MultiArray msg;
    msg.data.resize(7);
    msg.data[0] = q1;
    msg.data[1] = q2;
    msg.data[2] = q3;
    msg.data[3] = q4;
    msg.data[4] = q5;
    msg.data[5] = q6;
    msg.data[6] = q7;
    return msg;
}

void callback_goal_distance(const std_msgs::Float32::ConstPtr& msg)
{
  // if(msg->data-distance == 0)
    
  //      std::cout << "I've arrived" << goal_distance << std::endl;
  // goal_distance = msg->data;
}
int main (int argc, char** argv)
{
    std::cout << "Moving arms and base practice"<< std::endl;
    ros::init(argc, argv, "moving_practice");
    ros::NodeHandle n("~");


    ros::Publisher pub_distance       = n.advertise<std_msgs::Float32>("/simple_move/goal_distance", 1);
    // ros::Publisher servo_positions_l  = n.advertise<std_msgs::Float64MultiArray>("/hardware/left_arm/goal_pose", 1);
    ros::Publisher pub_aleatory_p     = n.advertise<geometry_msgs::PoseStamped>("/move_base_simple/goal",1);

    //ros::Subscriber goal_distance     =n.subscribe("/simple_move/goal_distance",callback_goal_distance );

    //pub_distance.publish(move_distance);
    //   int state = INIT_P;
    ros::Rate loop(10);
    ros::Time ros_time;
    loop.sleep();
    /*
    while(ros::ok())
    {
        switch(state)
        {
        case INIT_P:
            servo_positions_l.publish(servo_position(-1, 0, 0, 1.57, 0, 0.5, 0));
            state = W_FOR_POSE;
            ros_time = ros::Time::now();
            std::cout<<"new pose"<<std::endl;
            break;
            
        case W_FOR_POSE:
            if( (ros::Time::now() - ros_time).toSec()  > 4.0)
            { 
                state = SECOND_POSE;
                std::cout<<"Ten secs"<< std::endl;
            }
            break;
            
        case SECOND_POSE:
            servo_positions_l.publish(servo_position(0, 0, 0, 1.57, 0, 0.5, 0));
            state = W_FOR_POSE_TWO;
            ros_time = ros::Time::now();
            std::cout <<"second pose"<< std::endl;
            break;
        case W_FOR_POSE_TWO:
            if((ros::Time::now() - ros_time).toSec() > 10000);
            {
                state = THIRD_POSE;
                std::cout <<"wait second pose"<< std::endl;
            }
            break;
        case THIRD_POSE:
            servo_positions_l.publish(servo_position(0, 0, 0, 0, 0, 0, 0));
            std::cout <<"third pose"<< std::endl;
            break;
        }
        loop.sleep();
        ros:: spinOnce();
        }*/

    position.pose.position.x = .2;
    position.pose.position.y = .5;    
    position.pose.quaternion.z = .2;
                                                  

    pub_aleatory_p.publish(PointStamped());
    loop.sleep();
    ros:: spinOnce();

    
}
